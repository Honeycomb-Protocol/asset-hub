use {
    crate::{
        structs::{Assembler, AssemblingAction},
        utils::{create_master_edition, create_metadata},
    },
    anchor_lang::prelude::*,
    anchor_spl::token::{self, Mint, MintTo, Token, TokenAccount},
};

/// Accounts used in the create assembler instruction
#[derive(Accounts)]
pub struct CreateAssembler<'info> {
    /// Collection of the nfts generated by this assembler
    #[account(
      init,
      payer = payer,
      mint::decimals = 0,
      mint::authority = assembler,
      mint::freeze_authority = assembler,
    )]
    pub collection_mint: Account<'info, Mint>,

    /// Metadata account of the collection
    /// CHECK: This is not dangerous because we don't read or write from this account
    #[account(mut)]
    pub collection_metadata_account: AccountInfo<'info>,

    /// Assembler state account
    #[account(
      init, payer = payer,
      space = Assembler::LEN ,
      seeds = [
        b"assembler".as_ref(),
        collection_mint.key().as_ref(),
      ],
      bump,
    )]
    pub assembler: Account<'info, Assembler>,

    /// The wallet that holds the authority over the assembler
    /// CHECK: This is not dangerous because we don't read or write from this account
    pub authority: AccountInfo<'info>,

    /// The wallet that pays for the rent
    #[account(mut)]
    pub payer: Signer<'info>,

    /// NATIVE SYSTEM PROGRAM
    pub system_program: Program<'info, System>,

    /// SPL TOKEN PROGRAM
    #[account(address = token::ID)]
    pub token_program: Program<'info, Token>,

    /// METAPLEX TOKEN METADATA PROGRAM
    /// CHECK: This is not dangerous because we don't read or write from this account
    pub token_metadata_program: AccountInfo<'info>,

    /// SYSVAR RENT
    pub rent: Sysvar<'info, Rent>,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct CreateAssemblerArgs {
    assembling_action: AssemblingAction,
    collection_name: String,
    collection_symbol: String,
    collection_uri: String,
    collection_description: String,
    nft_base_uri: String,
    allow_duplicates: Option<bool>,
}

/// Create a new assembler
pub fn create_assembler(ctx: Context<CreateAssembler>, args: CreateAssemblerArgs) -> Result<()> {
    let assembler = &mut ctx.accounts.assembler;
    assembler.bump = ctx.bumps["assembler"];
    assembler.authority = ctx.accounts.authority.key();
    assembler.collection = ctx.accounts.collection_mint.key();
    assembler.collection_name = args.collection_name;
    assembler.collection_symbol = args.collection_symbol;
    assembler.collection_description = args.collection_description;
    assembler.nft_base_uri = args.nft_base_uri;
    assembler.assembling_action = args.assembling_action;
    assembler.nfts = 0;
    assembler.allow_duplicates = args.allow_duplicates.unwrap_or(false);

    let assembler_seeds = &[
        b"assembler".as_ref(),
        assembler.collection.as_ref(),
        &[assembler.bump],
    ];
    let assembler_signer = &[&assembler_seeds[..]];

    create_metadata(
        assembler.collection_name.clone(),
        assembler.collection_symbol.clone(),
        args.collection_uri,
        0,
        None,
        // Some(vec![mpl_token_metadata::state::Creator {
        //     address: assembler.authority,
        //     verified: true,
        //     share: 100,
        // }]),
        None,
        None,
        None,
        assembler.to_account_info(),
        ctx.accounts.payer.to_account_info(),
        ctx.accounts.collection_mint.to_account_info(),
        ctx.accounts.collection_metadata_account.clone(),
        ctx.accounts.system_program.to_account_info(),
        ctx.accounts.token_metadata_program.to_account_info(),
        ctx.accounts.rent.to_account_info(),
        Some(assembler_signer),
    )?;

    // let assembler_seeds = &[
    //     b"assembler".as_ref(),
    //     assembler.collection.as_ref(),
    //     &[assembler.bump],
    // ];
    // let assembler_signer = &[&assembler_seeds[..]];

    // let create_metadata = mpl_token_metadata::instruction::create_metadata_accounts_v3(
    //     ctx.accounts.token_metadata_program.key(),
    //     ctx.accounts.collection_metadata_account.key(),
    //     assembler.collection,
    //     assembler_key,
    //     ctx.accounts.payer.key(),
    //     assembler_key,
    //     assembler.collection_name.clone(),
    //     assembler.collection_symbol.clone(),
    //     args.collection_uri,
    //     None,
    //     // Some(vec![mpl_token_metadata::state::Creator {
    //     //     address: assembler.authority,
    //     //     verified: true,
    //     //     share: 100,
    //     // }]),
    //     0,
    //     false,
    //     true,
    //     None,
    //     None,
    //     None,
    // );

    // solana_program::program::invoke_signed(
    //     &create_metadata,
    //     &[
    //         ctx.accounts.collection_metadata_account.clone(),
    //         ctx.accounts.collection_mint.to_account_info(),
    //         assembler.to_account_info(),
    //         ctx.accounts.payer.to_account_info(),
    //         assembler.to_account_info(),
    //         ctx.accounts.system_program.to_account_info(),
    //         ctx.accounts.rent.to_account_info(),
    //     ],
    //     assembler_signer,
    // )?;

    Ok(())
}

/// Accounts used in the create assembler collection master edition instruction
#[derive(Accounts)]
pub struct CreateAssemblerCollectionMasterEdition<'info> {
    /// Collection of the nfts generated by this assembler
    #[account(mut)]
    pub collection_mint: Account<'info, Mint>,

    /// Metadata account of the collection
    /// CHECK: This is not dangerous because we don't read or write from this account
    #[account(mut)]
    pub collection_metadata_account: AccountInfo<'info>,

    /// Master Edition account of the collection
    /// CHECK: This is not dangerous because we don't read or write from this account
    #[account(mut)]
    pub collection_master_edition: AccountInfo<'info>,

    /// Collection token account
    #[account(mut, constraint = collection_token_account.mint == collection_mint.key() && collection_token_account.owner == assembler.authority)]
    pub collection_token_account: Account<'info, TokenAccount>,

    /// Assembler state account
    #[account(mut, has_one = authority)]
    pub assembler: Account<'info, Assembler>,

    /// The wallet that holds the authority over the assembler
    pub authority: Signer<'info>,

    /// The wallet that pays for the rent
    #[account(mut)]
    pub payer: Signer<'info>,

    /// NATIVE SYSTEM PROGRAM
    pub system_program: Program<'info, System>,

    /// SPL TOKEN PROGRAM
    #[account(address = token::ID)]
    pub token_program: Program<'info, Token>,

    /// METAPLEX TOKEN METADATA PROGRAM
    /// CHECK: This is not dangerous because we don't read or write from this account
    pub token_metadata_program: AccountInfo<'info>,

    /// SYSVAR RENT
    pub rent: Sysvar<'info, Rent>,
}

/// Complete assembler creation by creating the collection master edition
pub fn create_assembler_collection_master_edition(
    ctx: Context<CreateAssemblerCollectionMasterEdition>,
) -> Result<()> {
    let assembler = &mut ctx.accounts.assembler;
    let assembler_seeds = &[
        b"assembler".as_ref(),
        assembler.collection.as_ref(),
        &[assembler.bump],
    ];
    let assembler_signer = &[&assembler_seeds[..]];

    token::mint_to(
        CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            MintTo {
                mint: ctx.accounts.collection_mint.to_account_info(),
                to: ctx.accounts.collection_token_account.to_account_info(),
                authority: assembler.to_account_info(),
            },
            assembler_signer,
        ),
        1,
    )?;

    create_master_edition(
        ctx.accounts.collection_mint.to_account_info(),
        ctx.accounts.collection_metadata_account.to_account_info(),
        ctx.accounts.collection_master_edition.clone(),
        assembler.to_account_info(),
        ctx.accounts.payer.to_account_info(),
        ctx.accounts.system_program.to_account_info(),
        ctx.accounts.token_program.to_account_info(),
        ctx.accounts.token_metadata_program.clone(),
        ctx.accounts.rent.to_account_info(),
        Some(assembler_signer),
    )?;

    // let create_master_edition = mpl_token_metadata::instruction::create_master_edition_v3(
    //     ctx.accounts.token_metadata_program.key(),
    //     ctx.accounts.collection_master_edition.key(),
    //     ctx.accounts.collection_mint.key(),
    //     assembler_key,
    //     assembler_key,
    //     ctx.accounts.collection_metadata_account.key(),
    //     ctx.accounts.payer.key(),
    //     Some(0),
    // );

    // solana_program::program::invoke_signed(
    //     &create_master_edition,
    //     &[
    //         ctx.accounts.collection_master_edition.clone(),
    //         ctx.accounts.collection_mint.to_account_info(),
    //         assembler.to_account_info(),
    //         assembler.to_account_info(),
    //         ctx.accounts.payer.to_account_info(),
    //         ctx.accounts.collection_metadata_account.to_account_info(),
    //         ctx.accounts.token_program.to_account_info(),
    //         ctx.accounts.system_program.to_account_info(),
    //         ctx.accounts.rent.to_account_info(),
    //     ],
    //     assembler_signer,
    // )?;

    Ok(())
}

/// Accounts used in the create assembler instruction
#[derive(Accounts)]
pub struct UpdateAssembler<'info> {
    /// Assembler state account
    #[account(mut, has_one = authority)]
    pub assembler: Account<'info, Assembler>,

    /// The wallet that holds the authority over the assembler
    pub authority: Signer<'info>,

    /// The wallet that holds the authority over the assembler
    /// CHECK: This is not dangerous because we don't read or write from this account
    pub new_authority: Option<AccountInfo<'info>>,

    /// The wallet that pays for the rent
    #[account(mut)]
    pub payer: Signer<'info>,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct UpdateAssemblerArgs {
    assembling_action: AssemblingAction,
    nft_base_uri: String,
    allow_duplicates: Option<bool>,
}

/// Update an assembler
pub fn update_assembler(ctx: Context<UpdateAssembler>, args: UpdateAssemblerArgs) -> Result<()> {
    let assembler = &mut ctx.accounts.assembler;
    assembler.nft_base_uri = args.nft_base_uri;
    assembler.assembling_action = args.assembling_action;
    assembler.allow_duplicates = args.allow_duplicates.unwrap_or(assembler.allow_duplicates);

    let new_authority = &ctx.accounts.new_authority;
    if let Some(new_authority) = new_authority {
        assembler.authority = new_authority.key();
    }

    Ok(())
}
